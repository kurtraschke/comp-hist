#!/usr/bin/perl -w

use Getopt::Std;
use strict;
my(%Name, %Year, %Month, %Day, %Info);
my(%Color, %Shape, %Linkto, %Linkweight);
my(%Reference, %Type, %Status, %VCG_Weights);
my(%Opts, $Maxyear, $Minyear, %VPos, $vscale);

=head1 NAME

B<parsech> - Parse Comp-Hist

=head1 SYNOPSIS

A parser for the Computer History Graphing Project.

    parsech -o [dump|chml|info|vcg|biblio]
    parsech -h
    parsech -v 

=head1 ABSTRACT

parsech is a unified parser for the Comp-Hist project.
It came about thanks to the fact that I was sick of 
writing a new parser for each new format we decided to 
support.

Oh, and I wanted documentation, too.

=head1 DESCRIPTION

B<parsech> will take three arguments at this point,
plus all the files you want parsed.

=over 5

=item B<-o> output

This switch dictates the output format. Currently, it will 
take the following arguments: L<dump>, L<chml>, L<vcg>, L<info>, or L<biblio>.

=item B<-v> version

This switch will print out the version and exit.

=item B<-h> help

This switch will print a brief help message and exit.


=back

=head1 INTERNALS

=cut it out!

getopts('hvo:s:', \%Opts); #Get our options for parsing

if ( defined $Opts{s} ) {
    $vscale=$Opts{s};} else {
	$vscale=1;}
#now, the case statements for what to do
if( defined $Opts{h} ){ &help; exit; }
elsif( defined $Opts{v} ){ print("Parsech, version 1.5, 2000-10-4\n"); exit; }
elsif( defined $Opts{o} ) { &output; }
else{ print("Invalid args. See -h for proper usage\n"); exit; }

sub help {
    print("ParseCH, the Parser for Comp-Hist\n");
    print("\t-v - print a version and exit\n");
    print("\t-h - print this message and exit\n");
    print("\t-o - sets the output format, takes one arg, see man page for possible args\n");
}

sub output {
    if($Opts{o} eq "dump"){&dump;}
    elsif($Opts{o} eq "chml"){&chml;}
    elsif($Opts{o} eq "info"){&info;}
    elsif($Opts{o} eq "vcg"){&vcg;}
    elsif($Opts{o} eq "biblio"){&biblio;}
    else {print "Invalid output format: valid formats are dump, chml, vcg, and info\n"; exit;}
}

=head2 parse

The parse subroutine does the heavy lifting involved in parsing,
and really should be the only function that ever touches the 
file's contents.

The data fields are parsed as follows:

=over 5

=item First, a regexp filters out the comments (C<s/#.*//>)

=item Next, we check to see if it's a node nick field, and sets stuff up if it is.

=item Then, we look for a Name: field and set that up.

=item After that, date parsing happens.

=item Then, reference parsing is done.

=item As a follow up, we then do Info parsing

=item Then, we do the Type parsing. Note that to get colors from this, the setcolor routine must be run.

=item Then, status parsing happens. For shapes, do setshape.

=item And finally, we check to see if linking must occur, and call the linkup function if it must.

=back

=cut yourself a slice of rug and start coding

sub parse{
    no strict "refs";
    my($file, $node);
    foreach $file (@ARGV){
	open($file, $file);
	while(<$file>){
	    s/\#.*//;
	    
	    if(/^(\S+)/){ $node = $1; }
	    
	    if(/.*Name: (.*)/){ $Name{$node} = $1; }
	   
	    if (/.*Founded.*(\d\d\d\d)-(\d\d)-(\d\d)/){
	      $Year{$node}=$1; 
	      $Month{$node}=$2;
	      $Day{$node}=$3;
	    }
	    if (/.*Founded.*(\d\d\d\d)-(\d\d)/) {
	      $Year{$node}=$1;
	      $Month{$node}=$2;
	    }
	    if (/.*Founded.*(\d\d\d\d)/) {
	      $Year{$node}=$1;
	      $Month{$node}="0";
	    }

	    if (/.*Date:.*(\d\d\d\d)-(\d\d)-(\d\d)/){
	      $Year{$node}=$1;
	      $Month{$node}=$2;
	      $Day{$node}=$3;
	    }
	    if (/.*Date:.*(\d\d\d\d)-(\d\d)/) {
	      $Year{$node}=$1;
	      $Month{$node}=$2;
	    }
	    if (/.*Date:.*(\d\d\d\d)/) {
	      $Year{$node}=$1;
	      $Month{$node}="0";
	    }
	
	    if(/.*Reference: (.*)/){ $Reference{$node} = $1; }
	
	    if(/.*Info: (.*)/){ $Info{$node} = $1; }

	    if(/.*Type: hardware/){ $Type{$node} = "hardware"; }
	    if(/.*Type: os/i){ $Type{$node} = "os"; }
	    if(/.*Type: language/){ $Type{$node} = "language"; }
	    if(/.*Type: standard/){ $Type{$node} = "standard"; }
	    if(/.*Type: other/){ $Type{$node} = "other"; }
	    if(/.*Type: company/){ $Type{$node} = "company"; }
	    if(/.*Type: announcement/){ $Type{$node} = "announcement"; }

	    if(/.*Status: ([released|internal|prototype|research])/i){ $Status{$node} = $1; }
	    if(/.*Status: continual evolution/i){ $Status{$node} = "contev"; }

	    if(/.*Aka (\S+)/) { linkup($node, $1, "aka"); }
	    if (/.*Successor to (\S+)/) { linkup($node, $1, "successor"); }
	    if (/.*Code taken from (\S+)/) { linkup($node, $1, "codetaken"); }
	    if (/.*Influenced by (\S+)/) { linkup($node, $1, "influenced"); }
	    if(/.*Runs on (\S+)/){ linkup($node, $1, "runson"); }
	    if(/.*Ran on (\S+)/){ linkup($node, $1, "runson"); }
	    if(/.*Written in (\S+)/){ linkup($node, $1, "writtenin"); }
	}
    }
}

=head2 minmaxYear

This function reads in the %Year hash (created by L<parse>) and sets the variables $Maxyear and $Minyear accordingly.

=cut it out! that hurts!

sub dominmaxYear {
  $Maxyear=0;
  $Minyear=800000;
  foreach my $Year (values %Year){
    if($Year gt $Maxyear){ $Maxyear = int($Year); }
    if($Year lt $Minyear){ $Minyear = int($Year); }
  }
}

=head2 dopos

dopos reads in the nodes given to it as arguments and sets a vertical position for the node accordingly. Useful mostly for dot and L<vcg> output.

=cut , wrap, and print

sub dopos{
  my($node, $Year);
  my $file = shift;
  foreach $node (keys %Year){
    if(!defined $Month{$node}){
      $Year = int($Year{$node}) - $Minyear;
      $VPos{$node} = $Year * 12;
    }
    else{
      $Year = int($Year{$node}) - $Minyear;
      $VPos{$node} = $Year * 12 + $Month{$node};
    }
    $VPos{$node} = ($VPos{$node}/$vscale);
    print STDERR "VPos for node $Name{$node} is $VPos{$node}\n";
  }   
}

=head2 linkup

linkup is the routine that creates the @linkfrom, @linkto, and @linkweight arrays. Used mostly by L<parse>.

=cut ! Youre beautiful! A Day In The Life Of JAPH will be a hit!

sub linkup {
  push(@{$Linkto{$_[0]}}, $_[1]);
  push(@{$Linkweight{$_[0]}}, $_[2]);
  return 0;
}

=head2 dump

dump is a rough output format. All it does is sort the nodes and strip comments.

=cut ! that scene is all wrong!

sub dump {
    my $node;
    &parse;
    foreach $node (sort keys %Name){
	print("$node\n");
	print("\tName: $Name{$node}\n");
	print("\tDate $Year{$node}") if defined $Year{$node};
	print("-$Month{$node}") if defined $Month{$node};
	print("-$Day{$node}") if defined $Day{$node};
	print("\n") if defined $Year{$node};
	print("\tReference: $Reference{$node}\n") if defined $Reference{$node};
	print("\tInfo: $Info{$node}\n") if defined $Info{$node};
	print("\tType: $Type{$node}\n") if defined $Type{$node};
	print("\tStatus: $Status{$node}\n") if defined $Status{$node};
	print("\n");
    }
}

sub expnick {
    return "Aka" if $_[0] =~ /aka/;
    return "Successor to" if $_[0] =~ /successor/;
    return "Code taken from" if $_[0] =~ /codetaken/;
    return "Influenced by" if $_[0] =~ /influenced/;
    return "Runs on" if $_[0] =~ /runson/;
    return "Written in" if $_[0] =~ /writtenin/;
}

=head2 chml

The chml routine sucks in the files, and spits out a bit of CHML (Comp-Hist Markup Language).

=cut

sub chml{
    my($i, $node);
    &parse;
    print("<!DOCTYPE TREE PUBLIC \"-//Comp_Hist//DTD CHML 1.0//EN\" \"http://comp-hist.sourceforge.net/comp-hist.dtd\">\n\n");

    print("<tree>\n");

    foreach $node (sort keys %Name){
	print("<node>\n");
	print("\t<id>$node</id>\n");
	print("\t<name>$Name{$node}</name>\n");
	print("\t<date Year=\"$Year{$node}\"") if defined $Year{$node};
	print(" month=\"$Month{$node}\"") if defined $Month{$node}; 
	print(" day=\"$Day{$node}\"") if defined $Day{$node};
	print(" />\n") if defined $Year{$node};
	print("\t<type types=\"$Type{$node}\" />\n") if defined $Type{$node};
	print("\t<status status=\"$Status{$node}\" />\n") if defined $Status{$node};
	print("\t<reference>$Reference{$node} </reference>\n") if defined $Reference{$node};
	print("\t<info>$Info{$node} </info>\n") if defined $Info{$node};
	for( $i=0; $i <= $#{$Linkto{$node}}; $i++ ) {
	    print("\t<link linktype=\"${$Linkweight{$node}}[$i]\"><id>${$Linkto{$node}}[$i]</id></link>\n");
	}
	print("</node>\n\n");
    }

    print("</tree>\n");
}

=head2 info

The info routine parses the data and then, for each node with an Info: field, spits out the node name and its contents.

=cut

sub info{
    my $node;
    &parse;
    foreach $node (sort keys %Info){
	print("Info on $Name{$node}: $Info{$node}\n\n");
    }
}

=head2 biblio

This routine is quite similar in operation to the L<info> routine, except that it looks for Reference: fields.

=cut

sub biblio{
    my $node;
    &parse;
    foreach $node (sort keys %Reference){
        print("Bibliographical information for $Name{$node}: $Reference{$node}\n\n") if defined $Reference{$node};
    }
}

=head2 setcolor

The setcolor routine turns types of nodes into colors and stores them in the %Color hash. The rules for translation are below:

=over 5

=item hardware becomes blue

=item OSes are red

=item languages are green

=item standards are yellow

=item companies are cyan

=item and announcements are gold

=back

=cut

sub setcolor{
    my $node;
    foreach $node (keys %Type){
	$Color{$node} = "blue" if $Type{$node} =~ /^hardware/;
	$Color{$node} = "red" if $Type{$node} =~ /^os/i;
	$Color{$node} = "green" if $Type{$node} =~ /^language/;
	$Color{$node} = "yellow" if $Type{$node} =~ /^standard/;
	$Color{$node} = "cyan" if $Type{$node} =~ /^company/;
	$Color{$node} = "gold" if $Type{$node} =~ /^announcement/;
	$Color{$node} = "magenta" if $Type{$node} =~ /^other/;
    }
}

=head2 setshape

The setshape routine will set shapes for the nodes according to the following status/shape relationship:

=over 5

=item released/box

=item internal/triangle

=item continual evolution/ellipse

=item prototype/rhomb

=item research/triangle

=item otherwise/box

=back

=cut

sub setshape {
    my $node;
    %Shape = ();
    foreach $node (keys %Status){
	if ($Status{$node} =~ /^released/){ $Shape{$node} = "box"; }
	if ($Status{$node} =~ /^triangle/){ $Shape{$node} = "triangle";}
	if ($Status{$node} =~ /^contev/){$Shape{$node} = "ellipse";}
	if ($Status{$node} =~ /^prototype/){$Shape{$node} = "rhomb";}
	if ($Status{$node} =~ /^research/){$Shape{$node} = "triangle";}
	else {$Shape{$node} = "box";}
    }
}

=head2 setweights_vcg

This lovely little function sets up the weights for L<vcg> to use. 

=cut

sub setweights_vcg {
    my($node, $linkweight);
    foreach $node (keys %Name){
	foreach $linkweight (@{$Linkweight{$node}}){
	    @{$VCG_Weights{$node}} = '';
	    if($linkweight =~ /^aka/){
		push(@{$VCG_Weights{$node}}, "thickness: 8 arrowsize: 40 backarrowsize: 400");
	    }	    
	    elsif($linkweight =~ /^successor/){
		push(@{$VCG_Weights{$node}},  "thickness: 4 arrowsize: 20"); 
	    }	    
	    elsif($linkweight =~ /^codetaken/){
		push(@{$VCG_Weights{$node}},  "");
	    }	    
	    elsif($linkweight =~ /^influenced/){
		push(@{$VCG_Weights{$node}}, "linestyle: dashed");
	    }
	    elsif($linkweight =~ /^runson/){
		push(@{$VCG_Weights{$node}}, "thickness: 8 linestyle: dashed");
	    }	    
	    elsif($linkweight =~ /^writtenin/){
		push(@{$VCG_Weights{$node}}, "thickness: 6 linestyle: dashed");
	    }
	}
    }
}

=head2 vcg

The vcg subroutine is an adapted form of tovcg's "graph" routine. The changes are as follows:

=over 5

=item it calls dopos, setcolor, and setshape itself, rather than having external functions do that

=item it prints the surrounding VCG headings

=item it doesn't seperate the files from each other (yet)

=item and it takes care of linkage

=cut

sub vcg{
    &parse;
    &dominmaxYear;
    &dopos;
    &setcolor;
    &setshape;
    &setweights_vcg;
    my $node;
    print("graph: {\n\ttitle: \"The Computer Family Tree\"\n\n");
    foreach $node (sort keys %Name){
	print("\tnode: {\n\t\ttitle: \"$node\"\n");
	print("\t\tlabel: \"$Name{$node}\"\n");
	print("\t\tvertical_order: $VPos{$node}\n") if defined $VPos{$node};
	print("\t\tcolor: $Color{$node}\n") if defined $Color{$node};
	print("\t\tshape: $Shape{$node}\n") if defined $Shape{$node};
	print(" \t}\n");
	if(defined $Linkto{$node}){
	    for(my $i=0; $i < scalar(@{$Linkto{$node}}); $i++){
		print("\tedge: {\n");
		print("\t\tsourcename: \"$Linkto{$node}[$i]\"\n");
		print("\t\ttargetname: \"$node\" \n");
		print("\t\t$VCG_Weights{$node}[$i]\n") if defined $VCG_Weights{$node}[$i];
		print("\t}\n");
	    }
	}
    }
    print("}\n");
}

sub pyinit {
    &parse;
}
