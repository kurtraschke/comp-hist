#!/usr/bin/perl -w

use Getopt::Std;
use strict;
my(%Name, %Year, %Month, %Day, %Info);
my(%Reference, %Type, %Status, %Linkto);
my(%Opts);

{
  getopts('hvo:s:', \%Opts); #Get our options for parsing
  #now, the case statements for what to do
  if( defined $Opts{h} ){ &help; exit; }
  elsif( defined $Opts{v} ){ print("Parsech, version 2.0, 2000-11-29\n"); exit; }
  elsif( defined $Opts{o} ) { output(@ARGV); }
  else{ print("Invalid args. See -h for proper usage\n"); exit; }
}

sub help {
    print("ParseCH, the Parser for Comp-Hist\n");
    print("\t-v - print a version and exit\n");
    print("\t-h - print this message and exit\n");
    print("\t-o - sets the output format, takes one arg, see man page for possible args\n");
  }

sub output {
  if($Opts{o} eq "dump"){&dump(@_);}
  elsif($Opts{o} eq "chml"){&chml(@_);}
  elsif($Opts{o} eq "info"){&info(@_);}
  elsif($Opts{o} eq "vcg"){&vcg(@_);}
  elsif($Opts{o} eq "biblio"){&biblio(@_);}
  elsif($Opts{o} eq "dbm"){&dbm(@_);}
  elsif($Opts{o} eq "dot"){&dot(@_);}
  else {die "Invalid output format: valid formats are dump, chml, vcg, dbm, and info\n";}
}

sub parse{
  no strict "refs";
  my $node;
  foreach my $file (@_){
    open $file, $file;
    while(<$file>){
      s/\#.*//;
      if(/^(\S+)/){ $node = $1; }
      if(/^\tName: (.*)/){ $Name{$node} = $1; }
      if (/^\tFounded.*(\d\d\d\d)-(\d\d)-(\d\d)/){
	$Year{$node}=$1; 
	$Month{$node}=$2;
	$Day{$node}=$3;
      }
      elsif (/^\tFounded.*(\d\d\d\d)-(\d\d)/) {
	$Year{$node}=$1;
	$Month{$node}=$2;
      }
      elsif (/^\tFounded.*(\d\d\d\d)/) {
	$Year{$node}=$1;
	$Month{$node}="0";
      }
      
      if (/^\tDate:.*(\d\d\d\d)-(\d\d)-(\d\d)/){
	$Year{$node}=$1;
	$Month{$node}=$2;
	$Day{$node}=$3;
      }
      elsif (/^\tDate:.*(\d\d\d\d)-(\d\d)/) {
	$Year{$node}=$1;
	$Month{$node}=$2;
      }
      elsif (/^\tDate:.*(\d\d\d\d)/) {
	$Year{$node}=$1;
	$Month{$node}="0";
      }
      
      if(/^\tReference: (.*)/){ $Reference{$node} = $1; }
      
      if(/^\tInfo: (.*)/){ $Info{$node} = $1; }
      
      if(/^\tType: hardware/){ $Type{$node} = "hardware"; }
      elsif(/^\tType: os/i){ $Type{$node} = "os"; }
      elsif(/^\tType: language/){ $Type{$node} = "language"; }
      elsif(/^\tType: standard/){ $Type{$node} = "standard"; }
      elsif(/^\tType: other/){ $Type{$node} = "other"; }
      elsif(/^\tType: company/){ $Type{$node} = "company"; }
      elsif(/^\tType: announcement/){ $Type{$node} = "announcement"; }
      
      if(/^\tStatus: released/i){ $Status{$node} = "released"; }
      elsif(/^\tStatus: internal/i){ $Status{$node} = "internal"; }
      elsif(/^\tStatus: prototype/i){ $Status{$node} = "prototype"; }
      elsif(/^\tStatus: research/i){ $Status{$node} = "research"; }
      elsif(/^\tStatus: continual evolution/i){ $Status{$node} = "contev"; }
      
      if(/^\tAka (\S+)/) { linkup($node, $1, "aka"); }
      if (/^\tSuccessor to (\S+)/) { linkup($node, $1, "successor"); }
      if (/^\tCode taken from (\S+)/) { linkup($node, $1, "codetaken"); }
      if (/^\tInfluenced by (\S+)/) { linkup($node, $1, "influenced"); }
      if(/^\tRuns on (\S+)/){ linkup($node, $1, "runson"); }
      if(/^\tRan on (\S+)/){ linkup($node, $1, "runson"); }
      if(/^\tWritten in (\S+)/){ linkup($node, $1, "writtenin"); }
      
    }
  }
}

sub dominmaxYear {
  my $Maxyear=0;
  my $Minyear=800000;
  foreach my $Year (values %{$_[0]}){
    if($Year gt $Maxyear){ $Maxyear = int($Year); }
    if($Year lt $Minyear){ $Minyear = int($Year); }
  }
  return($Minyear, $Maxyear);
}

sub dopos{
  my($node, $Year, %VPos, $VScale);
  my($Minyear, $Maxyear) = &dominmaxYear;
  $VScale = $Opts{s} || 1;
  foreach $node (keys %{$_[0]}){
    if(!defined $Month{$node}){
      $Year = int($Year{$node}) - $Minyear;
      $VPos{$node} = $Year * 12;
    }
    else{
      $Year = int($Year{$node}) - $Minyear;
      $VPos{$node} = $Year * 12 + $Month{$node};
    }
    $VPos{$node} = ($VPos{$node}/$VScale);
#    print STDERR "VPos for node $Name{$node} is $VPos{$node}\n";
  }
  return %VPos;
}

sub linkup {
  $Linkto{$_[0]}{$_[1]} = $_[2];
}

sub dump {
  &parse(@_);
  foreach my $node (sort keys %Name){
    print("$node\n");
    print("\tName: $Name{$node}\n");
    print("\tDate $Year{$node}") if defined $Year{$node};
    print("-$Month{$node}") if defined $Month{$node};
    print("-$Day{$node}") if defined $Day{$node};
    print("\n") if defined $Year{$node};
    print("\tReference: $Reference{$node}\n") if defined $Reference{$node};
    print("\tInfo: $Info{$node}\n") if defined $Info{$node};
    print("\tType: $Type{$node}\n") if defined $Type{$node};
    print("\tStatus: $Status{$node}\n") if defined $Status{$node};
    foreach my $linkto (keys %{$Linkto{$node}}){
      print "\t", expnick($Linkto{$node}{$linkto}), " $linkto\n";
    }
    print("\n");
  }
}

sub expnick {
  return "Aka" if $_[0] =~ /aka/;
  return "Successor to" if $_[0] =~ /successor/;
  return "Code taken from" if $_[0] =~ /codetaken/;
  return "Influenced by" if $_[0] =~ /influenced/;
  return "Runs on" if $_[0] =~ /runson/;
  return "Written in" if $_[0] =~ /writtenin/;
}

sub chml{
  my($linkto, $node);
  &parse(@_);
  print("<!DOCTYPE TREE PUBLIC \"-//Comp_Hist//DTD CHML 1.0//EN\" \"http://comp-hist.sourceforge.net/comp-hist.dtd\">\n\n");
  
  print("<tree>\n");
  
  foreach $node (sort keys %Name){
    print("<node>\n");
    print("\t<id>$node</id>\n");
    print("\t<name>$Name{$node}</name>\n");
    print("\t<date Year=\"$Year{$node}\"") if defined $Year{$node};
    print(" month=\"$Month{$node}\"") if defined $Month{$node}; 
    print(" day=\"$Day{$node}\"") if defined $Day{$node};
    print(" />\n") if defined $Year{$node};
    print("\t<type types=\"$Type{$node}\" />\n") if defined $Type{$node};
    print("\t<status status=\"$Status{$node}\" />\n") if defined $Status{$node};
    print("\t<reference>$Reference{$node} </reference>\n") if defined $Reference{$node};
    print("\t<info>$Info{$node} </info>\n") if defined $Info{$node};
    foreach $linkto (keys %{$Linkto{$node}}){
      print("<link linktype=\"$Linkto{$node}{$linkto}\"><id>$linkto</id></link>");
    }
    print("</node>\n\n");
  }
  
  print("</tree>\n");
}

sub info{
    my $node;
    &parse(@_);
    foreach $node (sort keys %Info){
	print("Info on $Name{$node}: $Info{$node}\n\n");
    }
}

sub biblio{
    my $node;
    &parse(@_);
    foreach $node (sort keys %Reference){
        print("Bibliographical information for $Name{$node}: $Reference{$node}\n\n") if defined $Reference{$node};
    }
}

sub setcolor{
    my($node, %Color, %Type);
    %Type = %{$_[0]};
    foreach $node (keys %Type){
	$Color{$node} = "blue" if $Type{$node} =~ /^hardware/;
	$Color{$node} = "red" if $Type{$node} =~ /^os/i;
	$Color{$node} = "green" if $Type{$node} =~ /^language/;
	$Color{$node} = "yellow" if $Type{$node} =~ /^standard/;
	$Color{$node} = "cyan" if $Type{$node} =~ /^company/;
	$Color{$node} = "gold" if $Type{$node} =~ /^announcement/;
	$Color{$node} = "magenta" if $Type{$node} =~ /^other/;
    }
    return %Color;
}

sub setshape {
    my($node, %Shape, %Status);
    %Status = %{$_[0]};
    foreach $node (keys %Status){
	if ($Status{$node} =~ /^released/){ $Shape{$node} = "box"; }
	elsif ($Status{$node} =~ /^triangle/){ $Shape{$node} = "triangle";}
	elsif ($Status{$node} =~ /^contev/){$Shape{$node} = "ellipse";}
	elsif ($Status{$node} =~ /^prototype/){$Shape{$node} = "rhomb";}
	elsif ($Status{$node} =~ /^research/){$Shape{$node} = "triangle";}
	else {$Shape{$node} = "box";}
    }
    return %Status
}

sub setlinkcolor {
  my($linkcolor, $linkweight, %Linkcolor, %Linkto);
  foreach my $node (keys %{$_[0]}){
    foreach my $linkto (keys %{${$_[0]}{$node}}){
      $linkweight=${$_[0]}{$node}{$linkto};
      if($linkweight eq "aka"){$linkcolor="blue";}
      elsif($linkweight eq "successor"){$linkcolor="red";}
      elsif($linkweight eq "codetaken"){$linkcolor="orange";}
      elsif($linkweight eq "influenced"){$linkcolor="pink";}
      elsif($linkweight eq "runson"){$linkcolor="yellow";}
      elsif($linkweight eq "writtenin"){$linkcolor="green";}
      $Linkcolor{$node}{$linkto}=$linkcolor;
    }
  }
  return %Linkcolor;
}

sub vcg{
  my($node, $linkto, %Linkcolor, %Color, %Shape);
  my(%VPos);
  &parse(@_);
  %VPos = dopos(\%Year);
  %Color = setcolor(\%Type);
  %Shape = setshape(\%Status);
  %Linkcolor = setlinkcolor(\%Linkto);
  print("graph: {\n\ttitle: \"The Computer Family Tree\"\n\n");
  foreach $node (sort keys %Name){
    print("\tnode: {\n\t\ttitle: \"$node\"\n");
    print("\t\tlabel: \"$Name{$node}\"\n");
    print("\t\tvertical_order: $VPos{$node}\n") if defined $VPos{$node};
    print("\t\tcolor: $Color{$node}\n") if defined $Color{$node};
    print("\t\tshape: $Shape{$node}\n") if defined $Shape{$node};
    print(" \t}\n");
    foreach $linkto ( keys %{$Linkto{$node}}){
      print("\tedge:{\n");
      print("\t\tsourcename: \"$linkto\"\n");
      print("\t\ttargetname: \"$node\"\n");
      print("\t\tcolor: $Linkcolor{$node}{$linkto}\n");
      print("\t}\n");
    }
  }
  print("}\n");
}

sub dbm {
  use GDBM_File;
  no strict "subs";
  my %links;
  mkdir('parsech_dbm', 0777);
  mkdir('parsech_dbm/links', 0777);
  tie(%Name, 'GDBM_File', 'parsech_dbm/Name', &GDBM_WRCREAT, 0640);
  tie(%Year, 'GDBM_File', 'parsech_dbm/Year', &GDBM_WRCREAT, 0640);
  tie(%Month, 'GDBM_File', 'parsech_dbm/Month', &GDBM_WRCREAT, 0640);
  tie(%Day, 'GDBM_File', 'parsech_dbm/Day', &GDBM_WRCREAT, 0640);
  tie(%Info, 'GDBM_File', 'parsech_dbm/Info', &GDBM_WRCREAT, 0640);
  tie(%Type, 'GDBM_File', 'parsech_dbm/Type', &GDBM_WRCREAT, 0640);
  tie(%Reference, 'GDBM_File', 'parsech_dbm/Reference', &GDBM_WRCREAT, 0640);
  tie(%Status, 'GDBM_File', 'parsech_dbm/Status', &GDBM_WRCREAT, 0640);
  &parse(@_);
  untie(%Name);
  untie(%Year);
  untie(%Month);
  untie(%Day);
  untie(%Info);
  untie(%Type);
  untie(%Status);
  untie(%Reference);
  #Now, we store the links. Each node gets its own DBM database
  foreach my $node (keys %Linkto){
    tie(%links, 'GDBM_File', "parsech_dbm/links/$node", &GDBM_WRCREAT, 0640);
    %links=%{$Linkto{$node}};
    untie(%links);
    %links=();
  }
}

sub dot {
  &parse(@_);
  my($Minyear, $Maxyear) = &dominmaxYear;
  my %Vpos = dopos(\%Year);
  print("digraph comp_hist {\n");
  print("\tnode [shape=plaintext,fontsize=24]\n");
  print("\t{ edge\n\t\t[style=bold]\n");
  for ($Minyear..$Maxyear){ print "\t\t$_->\n";}
  print("\t\tfuture;\n");
  print("\t}\n");

  print("}\n");
}


 __END__

=head1 NAME

B<parsech> - Parse Comp-Hist

=head1 SYNOPSIS

A parser for the Computer History Graphing Project.

    parsech -o [dump|chml|info|vcg|biblio|dbm]
    parsech -h
    parsech -v
    parsech -s(desired dopos scaling)

=head1 ABSTRACT

parsech is a unified parser for the Comp-Hist project.
It came about thanks to the fact that I was sick of 
writing a new parser for each new format we decided to 
support.

Oh, and I wanted documentation, too.

=head1 DESCRIPTION

B<parsech> will take three arguments at this point,
plus all the files you want parsed:

=over 5

=item B<-o> output

This switch dictates the output format. Currently, it will 
take the following arguments: L<dump>, L<chml>, L<vcg>, L<info>, or L<biblio>.

=item B<-v> version

This switch will print out the version and exit.

=item B<-h> help

This switch will print a brief help message and exit.

=item B<-s> scaling

This switch will set the value used by L<dopos> to scale the L<vcg> output.

=back

For example, if you wanted to get VCG output from file foo, 
you would do the following:

=over 5

C<parsech -o vcg foo>

=back

However, if you were to want the scale to be decreased
by a factor of five, you would do this:

=over 5

C<parsech -s 5 -o vcg foo>

=back

And finally, if you decided you wanted XML output, you
would do this:

=over 5

C<parsech -o chml foo>

=back

=head1 AUTHOR

Scott Fenton, with the help of many others. Go to 
http://comp-hist.sourceforge.net for information
on contacting us

=head1 SEE ALSO

The doc/syntax file elsewhere in this source tree

The C parser one directory below here.	

The XML DTD in the xml subdirectory.

=head1 COPYRIGHT

Copyright (C) 2000, Scott Fenton, Kurt Raschke, and others

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

=cut
