#!/usr/bin/perl -w

use Getopt::Std;
use strict;
my(%name, %year, %month, %day, %info);
my(%color, %shape, %linkto, %linkweight);
my(%reference, %type, %status, %vcg_weights);
my(%opts, $maxyear, $minyear, %vpos);

=head1 NAME

B<parsech> - Parse Comp-Hist

=head1 SYNOPSIS

A parser for the Computer History Graphing Project.

    parsech B<-o> [dump|chml|info|vcg|biblio]
    parsech B<-h>
    parsech B<-v> 

=head1 ABSTRACT

parsech is a unified parser for the Comp-hist project.
It came about thanks to the fact that I was sick of 
writing a new parser for each new format we decided to 
support.

Oh, and I wanted documentation, too.

=head1 DESCRIPTION

B<parsech> will take three arguments at this point,
plus all the files you want parsed.

=over 5

=item B<-o> output

This switch dictates the output format. Currently, it will 
take the following arguments: L<dump|/"B_dump_">, L<chml|/"B_chml_">, L<vcg|/"B_vcg_">, L<info|/"B_info_">, or L<biblio|/"B_biblio_">.

=item B<-v> version

This switch will print out the version and exit.

=item B<-h> help

This switch will print a brief help message and exit.

=head1 INTERNALS

=cut it out!

getopts('hvo:', \%opts); #Get our options for parsing

#now, the case statements for what to do
if( defined $opts{h} ){ &help; exit; }
elsif( defined $opts{v} ){ print("Parsech, version 1.5, 2000-10-4\n"); exit; }
elsif( defined $opts{o} ) { &output; }
else{ print("Invalid args. See -h for proper usage\n"); exit; }

sub help {
    print("ParseCH, the Parser for Comp-Hist\n");
    print("\t-v - print a version and exit\n");
    print("\t-h - print this message and exit\n");
    print("\t-o - sets the output format, takes one arg, see man page for possible args\n");
}

sub output (){
    if($opts{o} =~ /dump/){&dump;}
    elsif($opts{o} =~ /chml/){&chml;}
    elsif($opts{o} =~ /info/){&info;}
    elsif($opts{o} =~ /vcg/){&vcg;}
    elsif($opts{o} =~ /biblio/){&biblio;}
    else {print "Invalid output format: valid formats are dump, chml, vcg, and info\n"; exit;}
}

=head2 B<parse>

The parse subroutine does the heavy lifting involved in parsing,
and really should be the only function that ever touches the 
file's contents.

The data fields are parsed as follows:

=over 5

=item First, a regexp filters out the comments (C<s/#.*//>)

=item Next, we check to see if it's a node nick field, and sets stuff up if it is.

=item Then, we look for a Name: field and set that up.

=item After that, date parsing happens.

=item Then, reference parsing is done.

=item As a follow up, we then do Info parsing

=item Then, we do the Type parsing. Note that to get colors from this, the setcolor routine must be run.

=item Then, status parsing happens. For shapes, do setshape.

=item And finally, we check to see if linking must occur, and call the linkup function if it must.

=back

=cut yourself a slice of rug and start coding

sub parse{
    no strict "refs";
    my($file, $node);
    foreach $file (@ARGV){
	open($file, $file);
	while(<$file>){
	    s/\#.*//;
	    
	    if(/^(\S+)/){ $node = $1; }

	    if(/.*Name: (.*)/){ $name{$node} = $1; }

	    if(/.*Date.*(\d\d\d\d)-?(\d\d)?-?(\d\d)?/){$year{$node} = $1; $month{$node} =  $2; $day{$node} = $3;}
	    if(/.*Founded.*(\d\d\d\d)-?(\d\d)?-?(\d\d)?/){$year{$node} = $1; $month{$node} =  $2; $day{$node} = $3;}
	
	    if(/.*Reference: (.*)/){ $reference{$node} = $1; }
	
	    if(/.*Info: (.*)/){ $info{$node} = $1; }

	    if(/.*Type: hardware/){ $type{$node} = "hardware"; }
	    if(/.*Type: os/i){ $type{$node} = "os"; }
	    if(/.*Type: language/){ $type{$node} = "language"; }
	    if(/.*Type: standard/){ $type{$node} = "standard"; }
	    if(/.*Type: other/){ $type{$node} = "other"; }
	    if(/.*Type: company/){ $type{$node} = "company"; }
	    if(/.*Type: announcement/){ $type{$node} = "announcement"; }

	    if(/.*Status: ([released|internal|prototype|research])/i){ $status{$node} = $1; }
	    if(/.*Status: continual evolution/i){ $status{$node} = "contev"; }

	    if(/.*Aka (\S+)/) { linkup($node, $1, "aka"); }
	    if (/.*Successor to (\S+)/) { linkup($node, $1, "successor"); }
	    if (/.*Code taken from (\S+)/) { linkup($node, $1, "codetaken"); }
	    if (/.*Influenced by (\S+)/) { linkup($node, $1, "influenced"); }
	    if(/.*Runs on (\S+)/){ linkup($node, $1, "runson"); }
	    if(/.*Ran on (\S+)/){ linkup($node, $1, "runson"); }
	    if(/.*Written in (\S+)/){ linkup($node, $1, "writtenin"); }
	}
    }
}

=head2 B<minmaxyear> 

This function reads in the %year hash (created by L<parse|/"B_parse_">) and sets the variables $maxyear and $minyear accordingly.

=cut it out! that hurts!

sub dominmaxyear {
    my $year;
    foreach $year (keys %year){
	if($year > $maxyear){ $maxyear = $year; }
	if($year < $minyear){ $minyear = $year; }
    }
}

=head2 B<dopos>

dopos reads in the nodes given to it as arguments and sets a vertical position for the node accordingly. Useful mostly for dot and L<vcg|/"B_vcg_"> output.

=cut , wrap, and print

sub dopos{
    my($node, $year);
    my $file = $_[0];
    foreach $node (@_){
	if(!defined $month{$node}){
	    $year = $year{$node} - $minyear;
	    $vpos{$node} = $year * 12;
	}
	else{
	    $year = $year{$node} - $minyear;
	    $vpos{$node} = $year * 12 + $month{$node};
	}
    }   
}

=head2 B<linkup>

linkup is the routine that creates the @linkfrom, @linkto, and @linkweight arrays. Used mostly by L<parse|/"B_parse_">

=cut ! You're beautiful! A Day In The Life Of JAPH will be a hit!

sub linkup {
    push(@{$linkto{$_[0]}}, $_[1]);
    push(@{$linkweight{$_[0]}}, $_[2]);
    return 0;
}

=head2 B<dump>

dump is a rough output format. All it does is sort the nodes and strip comments.

=cut ! that scene is all wrong!

sub dump {
    my $node;
    &parse;
    foreach $node (sort keys %name){
	print("$node\n");
	print("\tName: $name{$node}\n");
	print("\tDate $year{$node}") if defined $year{$node};
	print("-$month{$node}") if defined $month{$node};
	print("-$day{$node}") if defined $day{$node};
	print("\n") if defined $year{$node};
	print("\tReference: $reference{$node}\n") if defined $reference{$node};
	print("\tInfo: $info{$node}\n") if defined $info{$node};
	print("\tType: $type{$node}\n") if defined $type{$node};
	print("\tStatus: $status{$node}\n") if defined $status{$node};
	print("\n");
    }
}

sub expnick {
    return "Aka" if $_[0] =~ /aka/;
    return "Successor to" if $_[0] =~ /successor/;
    return "Code taken from" if $_[0] =~ /codetaken/;
    return "Influenced by" if $_[0] =~ /influenced/;
    return "Runs on" if $_[0] =~ /runson/;
    return "Written in" if $_[0] =~ /writtenin/;
}

=head2 B<chml>

The chml routine sucks in the files, and spits out a bit of CHML (Comp-Hist Markup Language).

=cut

sub chml{
    my($i, $node);
    &parse;
    print("<!DOCTYPE TREE PUBLIC \"-//Comp_Hist//DTD CHML 1.0//EN\" \"http://comp-hist.sourceforge.net/comp-hist.dtd\">\n\n");

    print("<tree>\n");

    foreach $node (sort keys %name){
	print("<node>\n");
	print("\t<id>$node</id>\n");
	print("\t<name>$name{$node}</name>\n");
	print("\t<date year=\"$year{$node}\"") if defined $year{$node};
	print(" month=\"$month{$node}\"") if defined $month{$node}; 
	print(" day=\"$day{$node}\"") if defined $day{$node};
	print(" />\n") if defined $year{$node};
	print("\t<type types=\"$type{$node}\" />\n") if defined $type{$node};
	print("\t<status status=\"$status{$node}\" />\n") if defined $status{$node};
	print("\t<reference>$reference{$node} </reference>\n") if defined $reference{$node};
	print("\t<info>$info{$node} </info>\n") if defined $info{$node};
	for( $i=0; $i <= $#{$linkto{$node}}; $i++ ) {
	    print("\t<link linktype=\"${$linkweight{$node}}[$i]\"><id>${$linkto{$node}}[$i]</id></link>\n");
	}
	print("</node>\n\n");
    }

    print("</tree>\n");
}

=head2 B<info>

The info routine parses the data and then, for each node with an Info: field, spits out the node name and its contents.

=cut

sub info{
    my $node;
    &parse;
    foreach $node (sort keys %info){
	print("Info on $name{$node}: $info{$node}\n\n");
    }
}

=head2 B<biblio>

This routine is quite similar in operation to the L<info|/"B_info_"> routine, except that it looks for Reference: fields.

=cut

sub biblio{
    my $node;
    &parse;
    foreach $node (sort keys %reference){
        print("Bibliographical information for $name{$node}: $reference{$node}\n\n") if defined $reference{$node};
    }
}

=head2 B<setcolor>

The setcolor routine turns types of nodes into colors and stores them in the %color hash. The rules for translation are below:

=over 5

=item hardware becomes blue

=item OSes are red

=item languages are green

=item standards are yellow

=item companies are cyan

=item and announcements are gold

=back

=cut

sub setcolor{
    my $node;
    foreach $node (keys %type){
	$color{$node} = "blue" if $type{$node} =~ /^hardware/;
	$color{$node} = "red" if $type{$node} =~ /^os/i;
	$color{$node} = "green" if $type{$node} =~ /^language/;
	$color{$node} = "yellow" if $type{$node} =~ /^standard/;
	$color{$node} = "cyan" if $type{$node} =~ /^company/;
	$color{$node} = "gold" if $type{$node} =~ /^announcement/;
	$color{$node} = "magenta" if $type{$node} =~ /^other/;
    }
}

=head2 B<setshape>

The setshape routine will set shapes for the nodes according to the following status/shape relationship:

=over 5

=item released/box

=item internal/triangle

=item continual evolution/ellipse

=item prototype/rhomb

=item research/triangle

=item otherwise/box

=back

=cut

sub setshape {
    my $node;
    %shape = ();
    foreach $node (keys %status){
	if ($status{$node} =~ /^released/){ $shape{$node} = "box"; }
	if ($status{$node} =~ /^triangle/){ $shape{$node} = "triangle";}
	if ($status{$node} =~ /^contev/){$shape{$node} = "ellipse";}
	if ($status{$node} =~ /^prototype/){$shape{$node} = "rhomb";}
	if ($status{$node} =~ /^research/){$shape{$node} = "triangle";}
	else {$shape{$node} = "box";}
    }
}

=head2 B<setweights_vcg>

This lovely little function sets up the weights for L<vcg|/"B_vcg_"> to use. 

=cut

sub setweights_vcg {
    my($node, $linkweight);
    foreach $node (keys %name){
	foreach $linkweight (@{$linkweight{$node}}){
	    @{$vcg_weights{$node}} = '';
	    if($linkweight =~ /^aka/){
		push(@{$vcg_weights{$node}}, "thickness: 8 arrowsize: 40 backarrowsize: 400");
	    }
	    
	    elsif($linkweight =~ /^successor/){
		push(@{$vcg_weights{$node}},  "thickness: 4 arrowsize: 20"); 
	    }
	    
	    elsif($linkweight =~ /^codetaken/){
		push(@{$vcg_weights{$node}},  "");
	    }
	    
	    elsif($linkweight =~ /^influenced/){
		push(@{$vcg_weights{$node}}, "linestyle: dashed");
	    }

	    elsif($linkweight =~ /^runson/){
		push(@{$vcg_weights{$node}}, "thickness: 8 linestyle: dashed");
	    }

	    elsif($linkweight =~ /^writtenin/){
		push(@{$vcg_weights{$node}}, "thickness: 6 linestyle: dashed");
	    }
	}
    }
}

=head2 B<vcg>

The vcg subroutine is an adapted form of tovcg's "graph" routine. The changes are as follows:

=over 5

=item it calls dopos, setcolor, and setshape itself, rather than having external functions do that

=item it prints the surrounding VCG headings

=item it doesn't seperate the files from each other (yet)

=item and it takes care of linkage

=cut

sub vcg{
    &parse;
    &dopos;
    &setcolor;
    &setshape;
    &setweights_vcg;
    my $node = '';
    my $i = 'n';
    print("graph: {\n\ttitle: \"The Computer Family Tree\"\n\n");
    foreach $node (sort keys %name){
	    print("\tnode: { title: \"$node\"");
	    print(" label: \"$name{$node}\"");
	    print(" vertical_order: $vpos{$node}") if defined $vpos{$node};
	    print(" color: $color{$node}") if defined $color{$node};
	    print(" shape: $shape{$node}") if defined $shape{$node};
	    print(" }\n");
	    if(defined $linkto{$node}){
		for($i=0; $i < scalar(@{$linkto{$node}}); $i++){
		    print("\tedge: { ");
		    print("sourcename: \"$linkto{$node}[$i]\" ");
		    print("targetname: \"$node\"  ");
		    print("$vcg_weights{$node}[$i] ") if defined $vcg_weights{$node}[$i];
		    print("}\n");
		}
	    }
	}
    print("}\n");
}
