#!/usr/bin/perl -w

use Getopt::Std;

=head1 NAME

B<parsech> - Parse Comp-Hist

=head1 SYNOPSIS

A parser for the Computer History Graphing Project.
    
    parsech B<-o> [dump|chml|info|vcg]
    parsech B<-h>
    parsech B<-v>

=head1 ABSTRACT

parsech is a unified parser for the Comp-hist project.
It came about thanks to the fact that I was sick of 
writing a new parser for each new format we decided to 
support.

Oh, and I wanted documentation, too.

=head1 DESCRIPTION

B<parsech> will take three arguments at this point,
plus all the files you want parsed.

=over 5

=item B<-o> output

This switch dictates the output format. Currently, it will 
take the following arguments: dump, chml, vcg, or info.

=item B<-v> version

This switch will print out the version and exit.

=item B<-h> help

This switch will print a brief help message and exit.

=head1 INTERNALS

=cut it out!

getopts('hvo:', \%opts); #Get our options for parsing

#now, the case statements for what to do
if( defined $opts{h} ){ &help; exit; }
elsif( defined $opts{v} ){ print("Parsech, version 0.03, 2000-9-23\n"); exit; }
elsif( defined $opts{o} ) { &output; }
else{ print("Invalid args. See -h for proper usage\n"); exit; }

sub help {
    print("ParseCH, the Parser for Comp-Hist\n");
    print("\t-v - print a version and exit\n");
    print("\t-h - print this message and exit\n");
    print("\t-o - sets the output format, takes one arg, see man page for possible args\n");
}

sub output (){
    foreach (@ARGV){
	open FILE, $_;
	while(<FILE>){
	    &parse;
	}
    }
    if($opts{o} =~ /dump/){&dump;}
    elsif($opts{o} =~ /chml/){&chml;}
    elsif($opts{o} =~ /info/){&info;}
    elsif($opts{o} =~ /vcg/){&vcg;}
    else {print "Invalid output format: valid formats are dump, chml, vcg, and info\n"; exit;}
}

=head2 B<parse>

The parse subroutine does the heavy lifting involved in parsing,
and really should be the only function that ever touches the 
file's contents.

The data fields are parsed as follows:

=over 5

=item First, a regexp filters out the comments (C<s/#.*//>)

=item Next, we check to see if it's a node nick field, and sets stuff up if it is.

=item Then, we look for a Name: field and set that up.

=item After that, date parsing happens.

=item Then, reference parsing is done.

=item As a follow up, we then do Info parsing

=item Then, we do the Type parsing. Note that to get colors from this, the setcolor routine must be run.

=item Then, status parsing happens. For shapes, do setshape.

=item And finally, we check to see if linking must occur, and call the linkup function if it must.

=cut yourself a slice of rug and start coding

sub parse{
	s/\#.*//;

	if(/^(\S+)/){ $node = $1; }

	if(/.*Name: (.*)/){ $name{$node} = $1; }

	if(/.*[Date|Founded].*(\d\d\d\d)-?(\d\d)?-?(\d\d)?/){$year{$node} = $1; $month{$node} =  $2; $day{$node} = $3;}

	if(/.*Reference: (.*)/){ $reference{$node} = $1; }

	if(/.*Info: (.*)/){ $info{$node} = $1; }

	if(/.*Type: hardware/){ $type{$node} = "hardware"; }
	if(/.*Type: os/i){ $type{$node} = "os"; }
	if(/.*Type: language/){ $type{$node} = "language"; }
	if(/.*Type: standard/){ $type{$node} = "standard"; }
	if(/.*Type: other/){ $type{$node} = "other"; }
	if(/.*Type: company/){ $type{$node} = "company"; }
	if(/.*Type: announcement/){ $type{$node} = "announcement"; }

	if(/.*Status: ([released|internal|prototype|research])/i){ $status{$node} = $1; }
	if(/.*Status: continual evolution/i){ $status{$node} = "contev"; }

	if(/.*Aka (\S+)/) { linkup($node, $1, "aka"); }
	if (/.*Successor to (\S+)/) { linkup($node, $1, "successor"); }
	if (/.*Code taken from (\S+)/) { linkup($node, $1, "codetaken"); }
	if (/.*Influenced by (\S+)/) { linkup($node, $1, "influenced"); }
	if(/.*Runs on (\S+)/){ linkup($node, $1, "runson"); }
	if(/.*Ran on (\S+)/){ linkup($node, $1, "runson"); }
	if(/.*Written in (\S+)/){ linkup($node, $1, "writtenin"); }
}

=head2 B<minmaxyear> 

This function reads in the %year hash (created by B<parse>) and sets the variables $maxyear and $minyear accordingly.

=cut it out! that hurts!

sub dominmaxyear {
    foreach $year (keys %year){
	if($year > $maxyear){ $maxyear = $year; }
	if($year < $minyear){ $minyear = $year; }
    }
}

=head2 B<dopos>

dopos reads in the nodes given to it as arguments and sets a vertical position for the node accordingly. Useful mostly for dot and vcg output.

=cut , wrap, and print

sub dopos{
    my $file = $_[0];
    foreach $node (@_){
	if(!defined $month{$node}){
	    $year = $year{$node} - $minyear;
	    $vpos{$node} = $year * 12;
	}
	else{
	    $year = $year{$node} - $minyear;
	    $vpos{$node} = $year * 12 + $month{$node};
	}
    }   
}

=head2 B<linkup>

linkup is the routine that creates the @linkfrom, @linkto, and @linkweight arrays. Used mostly by B<parse>

=cut ! You're beautiful! A Day In The Life Of JAPH will be a hit!

sub linkup {
    push(@{$linkto{$_[0]}}, $_[1]);
    push(@{$linkweight{$_[0]}}, $_[2]);
    return 0;
}

=head2 B<dump>

B<dump> is a rough output format. All it does is sort the nodes and strip comments.

=cut ! that scene is all wrong!

sub dump {
    foreach $node (sort keys %name){
	print("$node\n");
	print("\tName: $name{$node}\n");
	print("\tDate $year{$node}") if defined $year{$node};
	print("-$month{$node}") if defined $month{$node};
	print("-$day{$node}") if defined $day{$node};
	print("\n") if defined $year{$node};
	print("\tReference: $reference{$node}\n") if defined $reference{$node};
	print("\tInfo: $info{$node}\n") if defined $info{$node};
	print("\tType: $type{$node}\n") if defined $type{$node};
	print("\tStatus: $status{$node}\n") if defined $status{$node};
	print("\n");
    }
}

sub expnick {
    return "Aka" if $_[0] =~ /aka/;
    return "Successor to" if $_[0] =~ /successor/;
    return "Code taken from" if $_[0] =~ /codetaken/;
    return "Influenced by" if $_[0] =~ /influenced/;
    return "Runs on" if $_[0] =~ /runson/;
    return "Written in" if $_[0] =~ /writtenin/;
}

=head2 B<chml>

The chml routine sucks in the files, and spits out a bit of CHML (Comp-Hist Markup Language).

=cut

sub chml{
    print("<!DOCTYPE TREE PUBLIC \"-//Comp_Hist//DTD CHML 1.0//EN\" \"http://comp-hist.sourceforge.net/comp-hist.dtd\">\n\n");

    print("<tree>\n");

    foreach $node (sort keys %name){
	print("<node>\n");
	print("\t<id>$node</id>\n");
	print("\t<name>$name{$node}</name>\n");
	print("\t<date year=\"$year{$node}\"") if defined $year{$node};
	print(" month=\"$month{$node}\"") if defined $month{$node}; 
	print(" day=\"$day{$node}\"") if defined $day{$node};
	print(" />\n") if defined $year{$node};
	print("\t<type types=\"$type{$node}\" />\n") if defined $type{$node};
	print("\t<status status=\"$status{$node}\" />\n") if defined $status{$node};
	print("\t<reference>$reference{$node} </reference>\n") if defined $reference{$node};
	print("\t<info>$info{$node} </info>\n") if defined $info{$node};
	for( $i=0; $i <= $#{$linkto{$node}}; $i++ ) {
	    print("\t<link linktype=\"${$linkweight{$node}}[$i]\"><id>${$linkto{$node}}[$i]</id></link>\n");
	}
	print("</node>\n\n");
    }

    print("</tree>\n");
}

sub info{
    foreach $node (sort keys %info){
	print("Info on $name{$node}: $info{$node}\n\n");
    }
}

=head2 b<setcolor>

The setcolor routine turns types of nodes into colors and stores them in the %color hash. The rules for translation are below:

=over 5

=item hardware becomes blue

=item OSes are red

=item languages are green

=item standards are yellow

=item companies are cyan

=item and announcements are gold

=cut

sub setcolor{
    foreach $node (keys %type){
	$color{$node} = "blue" if $type{$node} =~ /^hardware/;
	$color{$node} = "red" if $type{$node} =~ /^os/i;
	$color{$node} = "green" if $type{$node} =~ /^language/;
	$color{$node} = "yellow" if $type{$node} =~ /^standard/;
	$color{$node} = "cyan" if $type{$node} =~ /^company/;
	$color{$node} = "gold" if $type{$node} =~ /^announcement/;
	$color{$node} = "magenta" if $type{$node} =~ /^other/;
    }
}

=head2 B<setshape>

The setshape routine will set shapes for the nodes according to the following status/shape relationship:

=over 5

=item released/box

=item internal/triangle

=item continual evolution/ellipse

=item prototype/rhomb

=item research/triangle

=item otherwise/box

=cut

sub setshape {
    foreach $node (keys %name){
	if ($status{$node} =~ /^released/){$shape{$node} = "box";}
	if ($status{$node} =~ /^triangle/){$shape{$node} = "triangle";}
	if ($status{$node} =~ /^contev/){$shape{$node} = "ellipse";}
	if ($status{$node} =~ /^prototype/){$shape{$node} = "rhomb";}
	if ($status{$node} =~ /^research/){$shape{$node} = "triangle";}
	else {$shape{$node} = "box";}
    }
}

=head2 B<vcg>

The vcg subroutine is an adapted form of tovcg's "graph" routine. The changes are as follows:

=over 5

=item it calls dopos, setcolor, and setshape itself, rather than having external functions do that

=item it prints the surrounding VCG headings

=item it doesn't seperate the files from each other (yet)

=item and it takes care of linkage

=cut

sub vcg{
    &dopos;
    &setcolor;
    &setshape;
    print("graph: {\n\ttitle: \"The Computer Family Tree\"\n\n");
    foreach $node (keys %name){
	if(!defined $vpos{$node}){
	    print("\t\tnode: { title: \"$node\" label: \"$name{$node}\" $color{$node} $shape{$node} }\n");
	}
	else{
	    print("\t\tnode: { title: \"$node\" label: \"$name{$node}\" vertical_order: $vpos{$node} $color{$node} $shape{$node} }\n");
	}
    }
    print("}\n");
}
